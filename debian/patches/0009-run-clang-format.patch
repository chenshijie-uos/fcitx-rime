From: Weng Xuetian <wengxt@gmail.com>
Date: Wed, 30 May 2018 09:24:14 -0700
Subject: run clang-format

Applied-Upstream: commit:16725fc95c2573263b366434ef061428ed57d1ed
---
 .clang-format               |  58 ++++
 clang-format.sh             |   2 +
 gui/src/Common.h            |  14 +-
 gui/src/ConfigMain.cpp      | 749 +++++++++++++++++++++++---------------------
 gui/src/ConfigMain.h        |  38 +--
 gui/src/FcitxRimeConfig.cpp | 447 +++++++++++++-------------
 gui/src/FcitxRimeConfig.h   |  61 ++--
 gui/src/Main.cpp            |  31 +-
 gui/src/Main.h              |   9 +-
 gui/src/Model.cpp           | 179 ++++++-----
 gui/src/Model.h             |  45 +--
 gui/src/keysym.h            |   2 +-
 12 files changed, 875 insertions(+), 760 deletions(-)
 create mode 100644 .clang-format
 create mode 100755 clang-format.sh

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..f93f79b
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,58 @@
+---
+Language:        Cpp
+# BasedOnStyle:  LLVM
+AccessModifierOffset: -4
+ConstructorInitializerIndentWidth: 4
+AlignEscapedNewlinesLeft: false
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: All
+AlwaysBreakTemplateDeclarations: true
+AlwaysBreakBeforeMultilineStrings: false
+BreakBeforeBinaryOperators: false
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BinPackParameters: true
+ColumnLimit:     80
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+DerivePointerAlignment: false
+ExperimentalAutoDetectBinPacking: false
+IndentCaseLabels: false
+IndentWrappedFunctionNames: false
+IndentFunctionDeclarationAfterType: false
+MaxEmptyLinesToKeep: 1
+KeepEmptyLinesAtTheStartOfBlocks: true
+NamespaceIndentation: None
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakString: 1000
+PenaltyBreakFirstLessLess: 120
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 60
+PointerAlignment: Right
+SpacesBeforeTrailingComments: 1
+Cpp11BracedListStyle: true
+Standard:        Cpp11
+IndentWidth:     4
+TabWidth:        4
+UseTab:          Never
+BreakBeforeBraces: Attach
+SpacesInParentheses: false
+SpacesInAngles:  false
+SpaceInEmptyParentheses: false
+SpacesInCStyleCastParentheses: false
+SpacesInContainerLiterals: true
+SpaceBeforeAssignmentOperators: true
+ContinuationIndentWidth: 4
+CommentPragmas:  '^ IWYU pragma:'
+ForEachMacros:   [ Q_FOREACH, BOOST_FOREACH ]
+SpaceBeforeParens: ControlStatements
+DisableFormat:   false
+SortIncludes: true
+...
+
diff --git a/clang-format.sh b/clang-format.sh
new file mode 100755
index 0000000..b6b8c25
--- /dev/null
+++ b/clang-format.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+find . \( -not \( -name 'keynametable.h' -o -name 'keysymgen.h' -o -name 'keysymdef.h' -o -name 'XF86keysym.h' \) \) -a \( -name '*.h' -o -name '*.cpp' \)  | xargs clang-format -i
diff --git a/gui/src/Common.h b/gui/src/Common.h
index ad0352d..f0f7f01 100644
--- a/gui/src/Common.h
+++ b/gui/src/Common.h
@@ -10,7 +10,7 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
@@ -18,20 +18,20 @@
 #ifndef FCITX_RIME_CONFIG_COMMON_H
 #define FCITX_RIME_CONFIG_COMMON_H
 
-#include <libintl.h>
 #include <QString>
+#include <libintl.h>
 
 #define _(x) QString::fromUtf8(dgettext("fcitx-rime", x))
 
 #define FCITX_RIME_ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
 
 namespace fcitx_rime {
-  inline QString tr2fcitx(const char *message, const char *comment = nullptr) {
+inline QString tr2fcitx(const char *message, const char *comment = nullptr) {
     if (message && message[0]) {
-      return QString(_(message));
+        return QString(_(message));
     } else {
-      return QString();
+        return QString();
     }
-  }
-};
+}
+};     // namespace fcitx_rime
 #endif // _FCITXRIMECONFIGCOMMON_H_
diff --git a/gui/src/ConfigMain.cpp b/gui/src/ConfigMain.cpp
index e3ce5ad..c5197f8 100644
--- a/gui/src/ConfigMain.cpp
+++ b/gui/src/ConfigMain.cpp
@@ -10,20 +10,20 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
 //
 #include <fcitx-config/xdg.h>
 
-#include <QtConcurrentRun>
-#include <QFutureWatcher>
 #include <QDialogButtonBox>
+#include <QFutureWatcher>
 #include <QTreeWidgetItem>
+#include <QtConcurrentRun>
 
-#include "ConfigMain.h"
 #include "Common.h"
+#include "ConfigMain.h"
 #include <QListWidgetItem>
 #include <QStandardItemModel>
 
@@ -31,9 +31,8 @@
 // TODO: when failed-save happens, disable ui and show reason
 
 namespace fcitx_rime {
-  ConfigMain::ConfigMain(QWidget* parent) :
-    FcitxQtConfigUIWidget(parent),
-    model(new FcitxRimeConfigDataModel()) {
+ConfigMain::ConfigMain(QWidget *parent)
+    : FcitxQtConfigUIWidget(parent), model(new FcitxRimeConfigDataModel()) {
     // Setup UI
     setMinimumSize(680, 500);
     setupUi(this);
@@ -44,222 +43,225 @@ namespace fcitx_rime {
     moveDownButton->setIcon(QIcon::fromTheme("go-down"));
     // configureButton->setIcon(QIcon::fromTheme("help-about"));
     // listViews for currentIM and availIM
-    QStandardItemModel* listModel = new QStandardItemModel();
+    QStandardItemModel *listModel = new QStandardItemModel();
     currentIMView->setModel(listModel);
-    QStandardItemModel* availIMModel = new QStandardItemModel();
+    QStandardItemModel *availIMModel = new QStandardItemModel();
     availIMView->setModel(availIMModel);
-    // tab shortcut 
-    connect(cand_cnt_spinbox, SIGNAL(valueChanged(int)), 
-            this, SLOT(stateChanged()));
-    QList<FcitxQtKeySequenceWidget*> keywgts =
-      general_tab->findChildren<FcitxQtKeySequenceWidget*>();
-    for(size_t i = 0; i < keywgts.size(); i ++) {
-      connect(keywgts[i], SIGNAL(keySequenceChanged(QKeySequence, FcitxQtModifierSide)),
-	      this, SLOT(keytoggleChanged()));
+    // tab shortcut
+    connect(cand_cnt_spinbox, SIGNAL(valueChanged(int)), this,
+            SLOT(stateChanged()));
+    QList<FcitxQtKeySequenceWidget *> keywgts =
+        general_tab->findChildren<FcitxQtKeySequenceWidget *>();
+    for (size_t i = 0; i < keywgts.size(); i++) {
+        connect(keywgts[i],
+                SIGNAL(keySequenceChanged(QKeySequence, FcitxQtModifierSide)),
+                this, SLOT(keytoggleChanged()));
     }
     // tab schemas
     connect(removeIMButton, SIGNAL(clicked(bool)), this, SLOT(removeIM()));
     connect(addIMButton, SIGNAL(clicked(bool)), this, SLOT(addIM()));
     connect(moveUpButton, SIGNAL(clicked(bool)), this, SLOT(moveUpIM()));
     connect(moveDownButton, SIGNAL(clicked(bool)), this, SLOT(moveDownIM()));
-    connect(availIMView->selectionModel(), SIGNAL(currentChanged(QModelIndex, QModelIndex)), this, SLOT(availIMSelectionChanged()));
-    connect(currentIMView->selectionModel(), SIGNAL(currentChanged(QModelIndex, QModelIndex)), this, SLOT(activeIMSelectionChanged()));
+    connect(availIMView->selectionModel(),
+            SIGNAL(currentChanged(QModelIndex, QModelIndex)), this,
+            SLOT(availIMSelectionChanged()));
+    connect(currentIMView->selectionModel(),
+            SIGNAL(currentChanged(QModelIndex, QModelIndex)), this,
+            SLOT(activeIMSelectionChanged()));
     rime = FcitxRimeConfigCreate();
     FcitxRimeConfigStart(rime);
     yamlToModel();
     modelToUi();
-  }
-  
-  ConfigMain::~ConfigMain() {
+}
+
+ConfigMain::~ConfigMain() {
     FcitxRimeDestroy(rime);
     delete model;
-  }
-  
-  void ConfigMain::keytoggleChanged() {
-    stateChanged();
-  }
-  
-  // SLOTs
-  void ConfigMain::stateChanged() {
-    emit changed(true);
-  }
-  
-  void ConfigMain::focusSelectedIM(const QString im_name) {
+}
+
+void ConfigMain::keytoggleChanged() { stateChanged(); }
+
+// SLOTs
+void ConfigMain::stateChanged() { emit changed(true); }
+
+void ConfigMain::focusSelectedIM(const QString im_name) {
     // search enabled IM first
     int sz = currentIMView->model()->rowCount();
-    for(int i = 0; i < sz; i ++) {
-      QModelIndex ind = currentIMView->model()->index(i, 0);
-      const QString name = currentIMView->model()->data(ind, Qt::DisplayRole).toString();
-      if(name == im_name) {
-	currentIMView->setCurrentIndex(ind);
-	currentIMView->setFocus();
-	return;
-      }
+    for (int i = 0; i < sz; i++) {
+        QModelIndex ind = currentIMView->model()->index(i, 0);
+        const QString name =
+            currentIMView->model()->data(ind, Qt::DisplayRole).toString();
+        if (name == im_name) {
+            currentIMView->setCurrentIndex(ind);
+            currentIMView->setFocus();
+            return;
+        }
     }
     // if not found, search avali IM list
     sz = availIMView->model()->rowCount();
-    for(int i = 0; i < sz; i ++) {
-      QModelIndex ind = availIMView->model()->index(i, 0);
-      const QString name = availIMView->model()->data(ind, Qt::DisplayRole).toString();
-      if(name == im_name) {
-	availIMView->setCurrentIndex(ind);
-	availIMView->setFocus();
-	return;
-      }
+    for (int i = 0; i < sz; i++) {
+        QModelIndex ind = availIMView->model()->index(i, 0);
+        const QString name =
+            availIMView->model()->data(ind, Qt::DisplayRole).toString();
+        if (name == im_name) {
+            availIMView->setCurrentIndex(ind);
+            availIMView->setFocus();
+            return;
+        }
     }
-  }
-  
-  void ConfigMain::addIM() {
-    if(availIMView->currentIndex().isValid()) {
-      const QString uniqueName =availIMView->currentIndex().data(Qt::DisplayRole).toString();
-      int largest = 0;
-      int find = -1;
-      for(size_t i = 0; i < model->schemas_.size(); i ++) {
-        if(model->schemas_[i].name == uniqueName) {
-	  find = i;
-	}
-	if(model->schemas_[i].index > largest) {
-	  largest = model->schemas_[i].index;
-	}
-      }
-      if(find != -1) {
-	model->schemas_[find].active = true;
-	model->schemas_[find].index = largest + 1;
-      }
-
-      model->sortSchemas();
-      updateIMList();
-      focusSelectedIM(uniqueName);
-      stateChanged();
+}
+
+void ConfigMain::addIM() {
+    if (availIMView->currentIndex().isValid()) {
+        const QString uniqueName =
+            availIMView->currentIndex().data(Qt::DisplayRole).toString();
+        int largest = 0;
+        int find = -1;
+        for (size_t i = 0; i < model->schemas_.size(); i++) {
+            if (model->schemas_[i].name == uniqueName) {
+                find = i;
+            }
+            if (model->schemas_[i].index > largest) {
+                largest = model->schemas_[i].index;
+            }
+        }
+        if (find != -1) {
+            model->schemas_[find].active = true;
+            model->schemas_[find].index = largest + 1;
+        }
+
+        model->sortSchemas();
+        updateIMList();
+        focusSelectedIM(uniqueName);
+        stateChanged();
     }
-  }
-  
-  void ConfigMain::removeIM() {
-    if(currentIMView->currentIndex().isValid()) {
-      const QString uniqueName = currentIMView->currentIndex().data(Qt::DisplayRole).toString();
-      for(size_t i = 0; i < model->schemas_.size(); i ++) {
-        if(model->schemas_[i].name == uniqueName) {
-          model->schemas_[i].active = false;
-          model->schemas_[i].index = 0;
+}
+
+void ConfigMain::removeIM() {
+    if (currentIMView->currentIndex().isValid()) {
+        const QString uniqueName =
+            currentIMView->currentIndex().data(Qt::DisplayRole).toString();
+        for (size_t i = 0; i < model->schemas_.size(); i++) {
+            if (model->schemas_[i].name == uniqueName) {
+                model->schemas_[i].active = false;
+                model->schemas_[i].index = 0;
+            }
         }
-      }
-      model->sortSchemas();
-      updateIMList();
-      focusSelectedIM(uniqueName);
-      stateChanged();
+        model->sortSchemas();
+        updateIMList();
+        focusSelectedIM(uniqueName);
+        stateChanged();
     }
-  }
-  
-  void ConfigMain::moveUpIM() {
-    if(currentIMView->currentIndex().isValid()) {
-      const QString uniqueName =currentIMView->currentIndex().data(Qt::DisplayRole).toString();
-      int cur_index = -1;
-      for(size_t i = 0; i < model->schemas_.size(); i ++) {
-        if(model->schemas_[i].name == uniqueName) {
-	  cur_index = model->schemas_[i].index;
-	  Q_ASSERT(cur_index == (i + 1)); // make sure the schema is sorted
-	}
-      }
-      // can't move up the top schema because the button should be grey
-      if(cur_index == -1 || cur_index == 0) {
-	return;
-      }
-
-      int temp;
-      temp = model->schemas_[cur_index - 1].index;
-      model->schemas_[cur_index - 1].index = model->schemas_[cur_index - 2].index;
-      model->schemas_[cur_index - 2].index = temp;
-      model->sortSchemas();
-      updateIMList();
-      focusSelectedIM(uniqueName);
-      stateChanged();
+}
+
+void ConfigMain::moveUpIM() {
+    if (currentIMView->currentIndex().isValid()) {
+        const QString uniqueName =
+            currentIMView->currentIndex().data(Qt::DisplayRole).toString();
+        int cur_index = -1;
+        for (size_t i = 0; i < model->schemas_.size(); i++) {
+            if (model->schemas_[i].name == uniqueName) {
+                cur_index = model->schemas_[i].index;
+                Q_ASSERT(cur_index ==
+                         (i + 1)); // make sure the schema is sorted
+            }
+        }
+        // can't move up the top schema because the button should be grey
+        if (cur_index == -1 || cur_index == 0) {
+            return;
+        }
+
+        int temp;
+        temp = model->schemas_[cur_index - 1].index;
+        model->schemas_[cur_index - 1].index =
+            model->schemas_[cur_index - 2].index;
+        model->schemas_[cur_index - 2].index = temp;
+        model->sortSchemas();
+        updateIMList();
+        focusSelectedIM(uniqueName);
+        stateChanged();
     }
-  }
-  
-  void ConfigMain::moveDownIM() {
-    if(currentIMView->currentIndex().isValid()) {
-      const QString uniqueName =currentIMView->currentIndex().data(Qt::DisplayRole).toString();
-      int cur_index = -1;
-      for(size_t i = 0; i < model->schemas_.size(); i ++) {
-        if(model->schemas_[i].name == uniqueName) {
-	  cur_index = model->schemas_[i].index;
-	  Q_ASSERT(cur_index == (i + 1)); // make sure the schema is sorted
-	}
-      }
-      // can't move down the bottom schema because the button should be grey
-      if(cur_index == -1 || cur_index == 0) {
-	return;
-      }
-      int temp;
-      temp = model->schemas_[cur_index - 1].index;
-      model->schemas_[cur_index - 1].index = model->schemas_[cur_index].index;
-      model->schemas_[cur_index].index = temp;
-      model->sortSchemas();
-      updateIMList();
-      focusSelectedIM(uniqueName);
-      stateChanged();
+}
+
+void ConfigMain::moveDownIM() {
+    if (currentIMView->currentIndex().isValid()) {
+        const QString uniqueName =
+            currentIMView->currentIndex().data(Qt::DisplayRole).toString();
+        int cur_index = -1;
+        for (size_t i = 0; i < model->schemas_.size(); i++) {
+            if (model->schemas_[i].name == uniqueName) {
+                cur_index = model->schemas_[i].index;
+                Q_ASSERT(cur_index ==
+                         (i + 1)); // make sure the schema is sorted
+            }
+        }
+        // can't move down the bottom schema because the button should be grey
+        if (cur_index == -1 || cur_index == 0) {
+            return;
+        }
+        int temp;
+        temp = model->schemas_[cur_index - 1].index;
+        model->schemas_[cur_index - 1].index = model->schemas_[cur_index].index;
+        model->schemas_[cur_index].index = temp;
+        model->sortSchemas();
+        updateIMList();
+        focusSelectedIM(uniqueName);
+        stateChanged();
     }
-  }
-  
-  void ConfigMain::availIMSelectionChanged() {
-    if(!availIMView->currentIndex().isValid()) {
-      addIMButton->setEnabled(false);
+}
+
+void ConfigMain::availIMSelectionChanged() {
+    if (!availIMView->currentIndex().isValid()) {
+        addIMButton->setEnabled(false);
     } else {
-      addIMButton->setEnabled(true);
+        addIMButton->setEnabled(true);
     }
-  }
-  
-  void ConfigMain::activeIMSelectionChanged() {
-    if(!currentIMView->currentIndex().isValid()) {
-      removeIMButton->setEnabled(false);
-      moveUpButton->setEnabled(false);
-      moveDownButton->setEnabled(false);
-      // configureButton->setEnabled(false);
-    } else {
-      removeIMButton->setEnabled(true);
-      // configureButton->setEnabled(true);
-      if(currentIMView->currentIndex().row() == 0) {
+}
+
+void ConfigMain::activeIMSelectionChanged() {
+    if (!currentIMView->currentIndex().isValid()) {
+        removeIMButton->setEnabled(false);
         moveUpButton->setEnabled(false);
-      } else {
-        moveUpButton->setEnabled(true);
-      }
-      if(currentIMView->currentIndex().row() == 
-        currentIMView->model()->rowCount() - 1)
-      {
         moveDownButton->setEnabled(false);
-      } else {
-        moveDownButton->setEnabled(true);
-      }
+        // configureButton->setEnabled(false);
+    } else {
+        removeIMButton->setEnabled(true);
+        // configureButton->setEnabled(true);
+        if (currentIMView->currentIndex().row() == 0) {
+            moveUpButton->setEnabled(false);
+        } else {
+            moveUpButton->setEnabled(true);
+        }
+        if (currentIMView->currentIndex().row() ==
+            currentIMView->model()->rowCount() - 1) {
+            moveDownButton->setEnabled(false);
+        } else {
+            moveDownButton->setEnabled(true);
+        }
     }
-  }
-  // end of SLOTs
-  
-  QString ConfigMain::icon() {
-    return "fcitx-rime";
-  }
-  
-  QString ConfigMain::addon() {
-    return "fcitx-rime";
-  }
-  
-  QString ConfigMain::title() {
-    return _("Fcitx Rime Config GUI Tool");
-  }
-  
-  void ConfigMain::load() {
-  }
-
-  void ConfigMain::setModelFromLayout(QVector<FcitxKeySeq>& model_keys, QLayout *layout) {
-    QList<FcitxQtKeySequenceWidget*> keys = getKeyWidgetsFromLayout(layout);
+}
+// end of SLOTs
+
+QString ConfigMain::icon() { return "fcitx-rime"; }
+
+QString ConfigMain::addon() { return "fcitx-rime"; }
+
+QString ConfigMain::title() { return _("Fcitx Rime Config GUI Tool"); }
+
+void ConfigMain::load() {}
+
+void ConfigMain::setModelFromLayout(QVector<FcitxKeySeq> &model_keys,
+                                    QLayout *layout) {
+    QList<FcitxQtKeySequenceWidget *> keys = getKeyWidgetsFromLayout(layout);
     model_keys.clear();
-    for(int i = 0; i < keys.size(); i ++) {
-      if(!keys[i]->keySequence().isEmpty()) {
-	model_keys.push_back(keys[i]->keySequence());
-      }
+    for (int i = 0; i < keys.size(); i++) {
+        if (!keys[i]->keySequence().isEmpty()) {
+            model_keys.push_back(keys[i]->keySequence());
+        }
     }
-  }
-  
-  void ConfigMain::uiToModel() {
+}
+
+void ConfigMain::uiToModel() {
     model->candidate_per_word = cand_cnt_spinbox->value();
     setModelFromLayout(model->toggle_keys, horizontallayout_toggle);
     setModelFromLayout(model->ascii_key, horizontallayout_ascii);
@@ -267,58 +269,66 @@ namespace fcitx_rime {
     setModelFromLayout(model->pgup_key, horizontallayout_pageup);
     setModelFromLayout(model->trasim_key, horizontallayout_trasim);
     setModelFromLayout(model->halffull_key, horizontallayout_hfshape);
-    
+
     // clear cuurent model and save from the ui
-    for(int i = 0; i < model->schemas_.size(); i ++) {
-      model->schemas_[i].index = 0;
-      model->schemas_[i].active = false;
+    for (int i = 0; i < model->schemas_.size(); i++) {
+        model->schemas_[i].index = 0;
+        model->schemas_[i].active = false;
     }
-    QStandardItemModel* qmodel = static_cast<QStandardItemModel*>(currentIMView->model());
+    QStandardItemModel *qmodel =
+        static_cast<QStandardItemModel *>(currentIMView->model());
     QModelIndex parent;
     int seqno = 1;
-    for(int r = 0; r < qmodel->rowCount(parent); ++r) {
-      QModelIndex index = qmodel->index(r, 0, parent);
-      QVariant name = qmodel->data(index);
-      for(int i = 0; i < model->schemas_.size(); i ++) {
-	if(model->schemas_[i].name == name) {
-	  model->schemas_[i].index = seqno ++;
-	  model->schemas_[i].active = true;
-	}
-      }
+    for (int r = 0; r < qmodel->rowCount(parent); ++r) {
+        QModelIndex index = qmodel->index(r, 0, parent);
+        QVariant name = qmodel->data(index);
+        for (int i = 0; i < model->schemas_.size(); i++) {
+            if (model->schemas_[i].name == name) {
+                model->schemas_[i].index = seqno++;
+                model->schemas_[i].active = true;
+            }
+        }
     }
     model->sortSchemas();
-  }
-  
-  void ConfigMain::save() {
+}
+
+void ConfigMain::save() {
     uiToModel();
-    QFutureWatcher<void>* futureWatcher = new QFutureWatcher<void>(this);
-    futureWatcher->setFuture(QtConcurrent::run<void>(this, &ConfigMain::modelToYaml));
+    QFutureWatcher<void> *futureWatcher = new QFutureWatcher<void>(this);
+    futureWatcher->setFuture(
+        QtConcurrent::run<void>(this, &ConfigMain::modelToYaml));
     connect(futureWatcher, SIGNAL(finished()), this, SIGNAL(saveFinished()));
-  }
+}
 
-  QList<FcitxQtKeySequenceWidget*> ConfigMain::getKeyWidgetsFromLayout(QLayout *layout) {
+QList<FcitxQtKeySequenceWidget *>
+ConfigMain::getKeyWidgetsFromLayout(QLayout *layout) {
     int count = layout->count();
-    QList<FcitxQtKeySequenceWidget*> out;
-    for(int i = 0; i < count; i ++) {
-      FcitxQtKeySequenceWidget* widget =
-	qobject_cast<FcitxQtKeySequenceWidget*>(layout->itemAt(i)->widget());
-      if(widget != NULL) {
-	out.push_back(widget);
-      }
+    QList<FcitxQtKeySequenceWidget *> out;
+    for (int i = 0; i < count; i++) {
+        FcitxQtKeySequenceWidget *widget =
+            qobject_cast<FcitxQtKeySequenceWidget *>(
+                layout->itemAt(i)->widget());
+        if (widget != NULL) {
+            out.push_back(widget);
+        }
     }
     return out;
-  }
+}
 
-  void ConfigMain::setKeySeqFromLayout(QLayout *layout, QVector<FcitxKeySeq>& model_keys) {
-    QList<FcitxQtKeySequenceWidget*> keywidgets = getKeyWidgetsFromLayout(layout);
+void ConfigMain::setKeySeqFromLayout(QLayout *layout,
+                                     QVector<FcitxKeySeq> &model_keys) {
+    QList<FcitxQtKeySequenceWidget *> keywidgets =
+        getKeyWidgetsFromLayout(layout);
     Q_ASSERT(keywidgets.size() >= model_keys.size());
-    for(int i = 0; i < model_keys.size(); i ++) {
-      keywidgets[i]->setKeySequence(QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(model_keys[i].sym_, model_keys[i].states_)));
+    for (int i = 0; i < model_keys.size(); i++) {
+        keywidgets[i]->setKeySequence(
+            QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(
+                model_keys[i].sym_, model_keys[i].states_)));
     }
     return;
-  }
-  
-  void ConfigMain::modelToUi() {
+}
+
+void ConfigMain::modelToUi() {
     cand_cnt_spinbox->setValue(model->candidate_per_word);
     // set shortcut keys
     setKeySeqFromLayout(horizontallayout_toggle, model->toggle_keys);
@@ -327,74 +337,80 @@ namespace fcitx_rime {
     setKeySeqFromLayout(horizontallayout_ascii, model->ascii_key);
     setKeySeqFromLayout(horizontallayout_trasim, model->trasim_key);
     setKeySeqFromLayout(horizontallayout_hfshape, model->halffull_key);
-    
+
     // set available and enabled input methods
-    for(size_t i = 0; i < model->schemas_.size(); i ++) {
-      auto& schema = model->schemas_[i];
-      if(schema.active) {
-        QStandardItem* active_schema = new QStandardItem(schema.name);
-	active_schema->setEditable(false);
-        auto qmodel = static_cast<QStandardItemModel*>(currentIMView->model());
-        qmodel->appendRow(active_schema);
-      } else {
-        QStandardItem* inactive_schema = new QStandardItem(schema.name);
-	inactive_schema->setEditable(false);
-        auto qmodel = static_cast<QStandardItemModel*>(availIMView->model());
-        qmodel->appendRow(inactive_schema);
-      }
+    for (size_t i = 0; i < model->schemas_.size(); i++) {
+        auto &schema = model->schemas_[i];
+        if (schema.active) {
+            QStandardItem *active_schema = new QStandardItem(schema.name);
+            active_schema->setEditable(false);
+            auto qmodel =
+                static_cast<QStandardItemModel *>(currentIMView->model());
+            qmodel->appendRow(active_schema);
+        } else {
+            QStandardItem *inactive_schema = new QStandardItem(schema.name);
+            inactive_schema->setEditable(false);
+            auto qmodel =
+                static_cast<QStandardItemModel *>(availIMView->model());
+            qmodel->appendRow(inactive_schema);
+        }
     }
-  }
+}
 
-  void ConfigMain::updateIMList() {
-    auto avail_IMmodel = static_cast<QStandardItemModel*>(availIMView->model());
-    auto active_IMmodel = static_cast<QStandardItemModel*>(currentIMView->model());
+void ConfigMain::updateIMList() {
+    auto avail_IMmodel =
+        static_cast<QStandardItemModel *>(availIMView->model());
+    auto active_IMmodel =
+        static_cast<QStandardItemModel *>(currentIMView->model());
     avail_IMmodel->removeRows(0, avail_IMmodel->rowCount());
     active_IMmodel->removeRows(0, active_IMmodel->rowCount());
-    for(size_t i = 0; i < model->schemas_.size(); i ++) {
-      auto& schema = model->schemas_[i];
-      if(schema.active) {
-        QStandardItem* active_schema = new QStandardItem(schema.name);
-	active_schema->setEditable(false);
-        active_IMmodel->appendRow(active_schema);
-      } else {
-        QStandardItem* inactive_schema = new QStandardItem(schema.name);
-	inactive_schema->setEditable(false);
-        avail_IMmodel->appendRow(inactive_schema);
-      }
+    for (size_t i = 0; i < model->schemas_.size(); i++) {
+        auto &schema = model->schemas_[i];
+        if (schema.active) {
+            QStandardItem *active_schema = new QStandardItem(schema.name);
+            active_schema->setEditable(false);
+            active_IMmodel->appendRow(active_schema);
+        } else {
+            QStandardItem *inactive_schema = new QStandardItem(schema.name);
+            inactive_schema->setEditable(false);
+            avail_IMmodel->appendRow(inactive_schema);
+        }
     }
-  }
-
-  // type: toggle 0, send 1
-  void ConfigMain::setModelKeysToYaml(QVector<FcitxKeySeq>& model_keys,
-				      int type, const char* key) {
-    char ** keys = (char **) fcitx_utils_malloc0(sizeof(char*) * model_keys.size());
-    for(int i = 0; i < model_keys.size(); i ++) {
-      std::string s = model_keys[i].toString();
-      keys[i] = (char*) fcitx_utils_malloc0(s.length() + 1);
-      memcpy(keys[i], s.c_str(), s.length());
+}
+
+// type: toggle 0, send 1
+void ConfigMain::setModelKeysToYaml(QVector<FcitxKeySeq> &model_keys, int type,
+                                    const char *key) {
+    char **keys =
+        (char **)fcitx_utils_malloc0(sizeof(char *) * model_keys.size());
+    for (int i = 0; i < model_keys.size(); i++) {
+        std::string s = model_keys[i].toString();
+        keys[i] = (char *)fcitx_utils_malloc0(s.length() + 1);
+        memcpy(keys[i], s.c_str(), s.length());
     }
     FcitxRimeConfigSetKeyBindingSet(rime->default_conf, type, key,
-      (const char **)keys, model_keys.size());
-    for(int i = 0; i < model_keys.size(); i ++) {
-      fcitx_utils_free(keys[i]);
+                                    (const char **)keys, model_keys.size());
+    for (int i = 0; i < model_keys.size(); i++) {
+        fcitx_utils_free(keys[i]);
     }
     fcitx_utils_free(keys);
-  }
-  
-  void ConfigMain::modelToYaml() {
-    rime->api->config_set_int(rime->default_conf,
-			      "menu/page_size", model->candidate_per_word);
-    char * * tkptrs = (char * * ) fcitx_utils_malloc0(model->toggle_keys.size());
-    for(size_t i = 0; i < model->toggle_keys.size(); i ++) {
-      std::string s = model->toggle_keys[i].toString();
-      tkptrs[i] = (char*)fcitx_utils_malloc0(s.length() + 1);
-      memset(tkptrs[i], 0, s.length() + 1);
-      memcpy(tkptrs[i], s.c_str(), s.length());
+}
+
+void ConfigMain::modelToYaml() {
+    rime->api->config_set_int(rime->default_conf, "menu/page_size",
+                              model->candidate_per_word);
+    char **tkptrs = (char **)fcitx_utils_malloc0(model->toggle_keys.size());
+    for (size_t i = 0; i < model->toggle_keys.size(); i++) {
+        std::string s = model->toggle_keys[i].toString();
+        tkptrs[i] = (char *)fcitx_utils_malloc0(s.length() + 1);
+        memset(tkptrs[i], 0, s.length() + 1);
+        memcpy(tkptrs[i], s.c_str(), s.length());
     }
-    FcitxRimeConfigSetToggleKeys(rime, rime->default_conf, (const char **)tkptrs,
-				 model->toggle_keys.size());
-    for(size_t i = 0; i < model->toggle_keys.size(); i ++) {
-      fcitx_utils_free(tkptrs[i]);
+    FcitxRimeConfigSetToggleKeys(rime, rime->default_conf,
+                                 (const char **)tkptrs,
+                                 model->toggle_keys.size());
+    for (size_t i = 0; i < model->toggle_keys.size(); i++) {
+        fcitx_utils_free(tkptrs[i]);
     }
     fcitx_utils_free(tkptrs);
 
@@ -406,81 +422,86 @@ namespace fcitx_rime {
 
     // set active schema list
     int active = 0;
-    char** schema_names = (char**)fcitx_utils_malloc0(sizeof(char*) * model->schemas_.size());
-    for(int i = 0; i < model->schemas_.size(); i ++) {
-      if(model->schemas_[i].index == 0) {
-	break;
-      } else {
-	std::string schema_id = model->schemas_[i].id.toStdString();
-	size_t len = schema_id.length();
-	schema_names[active] = (char*)fcitx_utils_malloc0(len + 1);
-	memcpy(schema_names[active], schema_id.c_str(), len);
-	active += 1;
-      }
+    char **schema_names =
+        (char **)fcitx_utils_malloc0(sizeof(char *) * model->schemas_.size());
+    for (int i = 0; i < model->schemas_.size(); i++) {
+        if (model->schemas_[i].index == 0) {
+            break;
+        } else {
+            std::string schema_id = model->schemas_[i].id.toStdString();
+            size_t len = schema_id.length();
+            schema_names[active] = (char *)fcitx_utils_malloc0(len + 1);
+            memcpy(schema_names[active], schema_id.c_str(), len);
+            active += 1;
+        }
     }
-    FcitxRimeClearAndSetSchemaList(rime, rime->default_conf, schema_names, active);
-    for(int i = 0; i < active; i ++) {
-      fcitx_utils_free(schema_names[i]);
+    FcitxRimeClearAndSetSchemaList(rime, rime->default_conf, schema_names,
+                                   active);
+    for (int i = 0; i < active; i++) {
+        fcitx_utils_free(schema_names[i]);
     }
     fcitx_utils_free(schema_names);
-    
+
     FcitxRimeConfigSync(rime);
     return;
-  }
-  
-  void ConfigMain::yamlToModel() {
+}
+
+void ConfigMain::yamlToModel() {
     FcitxRimeConfigOpenDefault(rime);
     // load page size
     int page_size = 0;
-    bool suc = rime->api->config_get_int(rime->default_conf, "menu/page_size", &page_size);
-    if(suc) {
-      model->candidate_per_word = page_size;
+    bool suc = rime->api->config_get_int(rime->default_conf, "menu/page_size",
+                                         &page_size);
+    if (suc) {
+        model->candidate_per_word = page_size;
     } else {
-      model->candidate_per_word = default_page_size;
+        model->candidate_per_word = default_page_size;
     }
     // toggle keys
-    size_t keys_size = FcitxRimeConfigGetToggleKeySize(rime, rime->default_conf);
+    size_t keys_size =
+        FcitxRimeConfigGetToggleKeySize(rime, rime->default_conf);
     keys_size = keys_size > max_shortcuts ? max_shortcuts : keys_size;
-    char** keys = (char**)fcitx_utils_malloc0(sizeof(char*) * keys_size);
+    char **keys = (char **)fcitx_utils_malloc0(sizeof(char *) * keys_size);
     FcitxRimeConfigGetToggleKeys(rime, rime->default_conf, keys, keys_size);
-    for(size_t i = 0; i < keys_size; i ++) {
-      if(strlen(keys[i]) != 0) { // skip the empty keys
-	model->toggle_keys.push_back(FcitxKeySeq(keys[i]));
-      }
-      fcitx_utils_free(keys[i]);
+    for (size_t i = 0; i < keys_size; i++) {
+        if (strlen(keys[i]) != 0) { // skip the empty keys
+            model->toggle_keys.push_back(FcitxKeySeq(keys[i]));
+        }
+        fcitx_utils_free(keys[i]);
     }
     fcitx_utils_free(keys);
     // load other shortcuts
     size_t buffer_size = 30;
-    char* accept = (char*)fcitx_utils_malloc0(buffer_size);
-    char* act_key = (char*)fcitx_utils_malloc0(buffer_size);
-    char* act_type = (char*)fcitx_utils_malloc0(buffer_size);
+    char *accept = (char *)fcitx_utils_malloc0(buffer_size);
+    char *act_key = (char *)fcitx_utils_malloc0(buffer_size);
+    char *act_type = (char *)fcitx_utils_malloc0(buffer_size);
     FcitxRimeBeginKeyBinding(rime->default_conf);
     size_t toggle_length = FcitxRimeConfigGetKeyBindingSize(rime->default_conf);
-    for(size_t i = 0; i < toggle_length; i ++) {
-      memset(accept, 0, buffer_size);
-      memset(act_key, 0, buffer_size);
-      memset(act_type, 0, buffer_size);
-      FcitxRimeConfigGetNextKeyBinding(rime->default_conf, act_type, act_key, accept, buffer_size);
-
-      if(strlen(accept) != 0) {
-	if(strcmp(act_key, "ascii_mode") == 0) {
-	  FcitxKeySeq seq = FcitxKeySeq(accept);
-	  model->ascii_key.push_back(seq);
-	} else if (strcmp(act_key, "full_shape") == 0) {
-	  FcitxKeySeq seq = FcitxKeySeq(accept);
-	  model->halffull_key.push_back(seq);
-	} else if (strcmp(act_key, "simplification") == 0) {
-	  FcitxKeySeq seq = FcitxKeySeq(accept);
-	  model->trasim_key.push_back(seq);
-	} else if (strcmp(act_key, "Page_Up") == 0) {
-	  FcitxKeySeq seq = FcitxKeySeq(accept);
-	  model->pgup_key.push_back(seq);
-	} else if (strcmp(act_key, "Page_Down") == 0) {
-	  FcitxKeySeq seq = FcitxKeySeq(accept);
-	  model->pgdown_key.push_back(seq);
-	}
-      }
+    for (size_t i = 0; i < toggle_length; i++) {
+        memset(accept, 0, buffer_size);
+        memset(act_key, 0, buffer_size);
+        memset(act_type, 0, buffer_size);
+        FcitxRimeConfigGetNextKeyBinding(rime->default_conf, act_type, act_key,
+                                         accept, buffer_size);
+
+        if (strlen(accept) != 0) {
+            if (strcmp(act_key, "ascii_mode") == 0) {
+                FcitxKeySeq seq = FcitxKeySeq(accept);
+                model->ascii_key.push_back(seq);
+            } else if (strcmp(act_key, "full_shape") == 0) {
+                FcitxKeySeq seq = FcitxKeySeq(accept);
+                model->halffull_key.push_back(seq);
+            } else if (strcmp(act_key, "simplification") == 0) {
+                FcitxKeySeq seq = FcitxKeySeq(accept);
+                model->trasim_key.push_back(seq);
+            } else if (strcmp(act_key, "Page_Up") == 0) {
+                FcitxKeySeq seq = FcitxKeySeq(accept);
+                model->pgup_key.push_back(seq);
+            } else if (strcmp(act_key, "Page_Down") == 0) {
+                FcitxKeySeq seq = FcitxKeySeq(accept);
+                model->pgdown_key.push_back(seq);
+            }
+        }
     }
     fcitx_utils_free(accept);
     fcitx_utils_free(act_key);
@@ -488,31 +509,35 @@ namespace fcitx_rime {
     FcitxRimeEndKeyBinding(rime->default_conf);
     model->sortKeys();
     getAvailableSchemas();
-  }
-  
-  void ConfigMain::getAvailableSchemas() {
-    const char* absolute_path = RimeGetUserDataDir();
-    FcitxStringHashSet* files = FcitxXDGGetFiles(fcitx_rime_dir_prefix, NULL, fcitx_rime_schema_suffix);
+}
+
+void ConfigMain::getAvailableSchemas() {
+    const char *absolute_path = RimeGetUserDataDir();
+    FcitxStringHashSet *files =
+        FcitxXDGGetFiles(fcitx_rime_dir_prefix, NULL, fcitx_rime_schema_suffix);
     HASH_SORT(files, fcitx_utils_string_hash_set_compare);
     HASH_FOREACH(f, files, FcitxStringHashSet) {
-      auto schema = FcitxRimeSchema();
-      schema.path = QString::fromLocal8Bit(f->name).prepend(absolute_path);
-      auto basefilename = QString::fromLocal8Bit(f->name).section(".",0,0);
-      size_t buffer_size = 50;
-      char* name = static_cast<char*>(fcitx_utils_malloc0(buffer_size));
-      char* id = static_cast<char*>(fcitx_utils_malloc0(buffer_size));
-      FcitxRimeGetSchemaAttr(rime, basefilename.toStdString().c_str(), name, buffer_size, "schema/name");
-      FcitxRimeGetSchemaAttr(rime, basefilename.toStdString().c_str(), id, buffer_size, "schema/schema_id");
-      schema.name = QString::fromLocal8Bit(name);
-      schema.id = QString::fromLocal8Bit(id);
-      schema.index = FcitxRimeCheckSchemaEnabled(rime, rime->default_conf, id);
-      schema.active = (bool)schema.index;
-      fcitx_utils_free(name);
-      fcitx_utils_free(id);
-      model->schemas_.push_back(schema);
+        auto schema = FcitxRimeSchema();
+        schema.path = QString::fromLocal8Bit(f->name).prepend(absolute_path);
+        auto basefilename = QString::fromLocal8Bit(f->name).section(".", 0, 0);
+        size_t buffer_size = 50;
+        char *name = static_cast<char *>(fcitx_utils_malloc0(buffer_size));
+        char *id = static_cast<char *>(fcitx_utils_malloc0(buffer_size));
+        FcitxRimeGetSchemaAttr(rime, basefilename.toStdString().c_str(), name,
+                               buffer_size, "schema/name");
+        FcitxRimeGetSchemaAttr(rime, basefilename.toStdString().c_str(), id,
+                               buffer_size, "schema/schema_id");
+        schema.name = QString::fromLocal8Bit(name);
+        schema.id = QString::fromLocal8Bit(id);
+        schema.index =
+            FcitxRimeCheckSchemaEnabled(rime, rime->default_conf, id);
+        schema.active = (bool)schema.index;
+        fcitx_utils_free(name);
+        fcitx_utils_free(id);
+        model->schemas_.push_back(schema);
     }
     fcitx_utils_free_string_hash_set(files);
     model->sortSchemas();
-  }
+}
 
-};
+}; // namespace fcitx_rime
diff --git a/gui/src/ConfigMain.h b/gui/src/ConfigMain.h
index cfdc29d..d5810f5 100644
--- a/gui/src/ConfigMain.h
+++ b/gui/src/ConfigMain.h
@@ -10,7 +10,7 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
@@ -21,23 +21,23 @@
 #include <fcitxqtconfiguiwidget.h>
 #include <fcitxqtkeysequencewidget.h>
 
-#include "ui_ConfigMain.h"
-#include "Model.h"
 #include "FcitxRimeConfig.h"
+#include "Model.h"
+#include "ui_ConfigMain.h"
 
 namespace fcitx_rime {
-  class ConfigMain : public FcitxQtConfigUIWidget, private Ui::MainUI {
+class ConfigMain : public FcitxQtConfigUIWidget, private Ui::MainUI {
     Q_OBJECT
-  public:
-    explicit ConfigMain(QWidget* parent = 0);
+public:
+    explicit ConfigMain(QWidget *parent = 0);
     QString title() override;
     ~ConfigMain();
     void load() override;
     void save() override;
-    
+
     QString addon() override;
     QString icon() override;
-  public slots:
+public slots:
     void keytoggleChanged();
     void stateChanged();
     void addIM();
@@ -46,10 +46,11 @@ namespace fcitx_rime {
     void moveDownIM();
     void availIMSelectionChanged();
     void activeIMSelectionChanged();
-  private:
-    FcitxRime* rime;
-    FcitxRimeConfigDataModel* model;
-    void setFcitxQtKeySeq(char* rime_key, FcitxKeySeq& keyseq);
+
+private:
+    FcitxRime *rime;
+    FcitxRimeConfigDataModel *model;
+    void setFcitxQtKeySeq(char *rime_key, FcitxKeySeq &keyseq);
     void yamlToModel();
     void uiToModel();
     void modelToUi();
@@ -57,11 +58,12 @@ namespace fcitx_rime {
     void getAvailableSchemas();
     void updateIMList();
     void focusSelectedIM(const QString im_name);
-    QList<FcitxQtKeySequenceWidget*> getKeyWidgetsFromLayout(QLayout *layout);
-    void setKeySeqFromLayout(QLayout *layout, QVector<FcitxKeySeq>& model_keys);
-    void setModelFromLayout(QVector<FcitxKeySeq>& model_keys, QLayout *layout);
-    void setModelKeysToYaml(QVector<FcitxKeySeq>& model_keys, int type, const char* key);
-  };
-}
+    QList<FcitxQtKeySequenceWidget *> getKeyWidgetsFromLayout(QLayout *layout);
+    void setKeySeqFromLayout(QLayout *layout, QVector<FcitxKeySeq> &model_keys);
+    void setModelFromLayout(QVector<FcitxKeySeq> &model_keys, QLayout *layout);
+    void setModelKeysToYaml(QVector<FcitxKeySeq> &model_keys, int type,
+                            const char *key);
+};
+} // namespace fcitx_rime
 
 #endif // FCITX_RIME_CONFIGMAIN_H
diff --git a/gui/src/FcitxRimeConfig.cpp b/gui/src/FcitxRimeConfig.cpp
index 4fe4d00..bf8c36a 100644
--- a/gui/src/FcitxRimeConfig.cpp
+++ b/gui/src/FcitxRimeConfig.cpp
@@ -10,263 +10,276 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
 //
+#include "FcitxRimeConfig.h"
 #include <fcitx-config/xdg.h>
 #include <fcitx-utils/utils.h>
-#include "FcitxRimeConfig.h"
 
-static RimeConfigIterator* global_iterator;
+static RimeConfigIterator *global_iterator;
 
-FcitxRime* FcitxRimeConfigCreate() {
-  FcitxRime* rime = (FcitxRime*) fcitx_utils_malloc0(sizeof(FcitxRime));
-  rime->api = rime_get_api();
-  rime->firstRun = True;
-  rime->default_conf = NULL;
-  if (!rime->api) {
-    free(rime);
-    return NULL;
-  }
-  return rime;
+FcitxRime *FcitxRimeConfigCreate() {
+    FcitxRime *rime = (FcitxRime *)fcitx_utils_malloc0(sizeof(FcitxRime));
+    rime->api = rime_get_api();
+    rime->firstRun = True;
+    rime->default_conf = NULL;
+    if (!rime->api) {
+        free(rime);
+        return NULL;
+    }
+    return rime;
 }
 
-void FcitxRimeConfigStart(FcitxRime* rime) {
-  char* user_path = NULL;
-  FILE* fp = FcitxXDGGetFileUserWithPrefix(fcitx_rime_dir_prefix, ".place_holder", "w", NULL);
-  if (fp) {
-    fclose(fp);
-  }
-  FcitxXDGGetFileUserWithPrefix(fcitx_rime_dir_prefix, "", NULL, &user_path);
-  const char* shared_data_dir = fcitx_utils_get_fcitx_path_with_filename("pkgdatadir", fcitx_rime_dir_prefix);
-  RIME_STRUCT(RimeTraits, fcitx_rime_traits);
-  fcitx_rime_traits.shared_data_dir = shared_data_dir;
-  fcitx_rime_traits.app_name = "rime.fcitx-rime-config";
-  fcitx_rime_traits.user_data_dir = user_path;
-  fcitx_rime_traits.distribution_name = "Rime";
-  fcitx_rime_traits.distribution_code_name = "fcitx-rime-config";
-  fcitx_rime_traits.distribution_version = "0.0.2";
-  if(rime->firstRun) {
-    rime->api->setup(&fcitx_rime_traits);
-    rime->firstRun = False;
-  }
-  rime->api->initialize(&fcitx_rime_traits);
+void FcitxRimeConfigStart(FcitxRime *rime) {
+    char *user_path = NULL;
+    FILE *fp = FcitxXDGGetFileUserWithPrefix(fcitx_rime_dir_prefix,
+                                             ".place_holder", "w", NULL);
+    if (fp) {
+        fclose(fp);
+    }
+    FcitxXDGGetFileUserWithPrefix(fcitx_rime_dir_prefix, "", NULL, &user_path);
+    const char *shared_data_dir = fcitx_utils_get_fcitx_path_with_filename(
+        "pkgdatadir", fcitx_rime_dir_prefix);
+    RIME_STRUCT(RimeTraits, fcitx_rime_traits);
+    fcitx_rime_traits.shared_data_dir = shared_data_dir;
+    fcitx_rime_traits.app_name = "rime.fcitx-rime-config";
+    fcitx_rime_traits.user_data_dir = user_path;
+    fcitx_rime_traits.distribution_name = "Rime";
+    fcitx_rime_traits.distribution_code_name = "fcitx-rime-config";
+    fcitx_rime_traits.distribution_version = "0.0.2";
+    if (rime->firstRun) {
+        rime->api->setup(&fcitx_rime_traits);
+        rime->firstRun = False;
+    }
+    rime->api->initialize(&fcitx_rime_traits);
 }
 
-RimeConfig* FcitxRimeConfigOpenDefault(FcitxRime* rime) {
-  RimeConfig* fcitx_rime_config_default = (RimeConfig*) fcitx_utils_malloc0(sizeof(RimeConfig));
-  Bool suc = rime->api->config_open("default", fcitx_rime_config_default);
-  if (!suc) {
-    return NULL;
-  }
-  rime->default_conf = fcitx_rime_config_default;
-  return fcitx_rime_config_default;
+RimeConfig *FcitxRimeConfigOpenDefault(FcitxRime *rime) {
+    RimeConfig *fcitx_rime_config_default =
+        (RimeConfig *)fcitx_utils_malloc0(sizeof(RimeConfig));
+    Bool suc = rime->api->config_open("default", fcitx_rime_config_default);
+    if (!suc) {
+        return NULL;
+    }
+    rime->default_conf = fcitx_rime_config_default;
+    return fcitx_rime_config_default;
 }
-  
-void FcitxRimeConfigSetToggleKeys(FcitxRime* rime, RimeConfig* config, const char** keys,
-				  size_t keys_size) {
-  RimeConfigClear(config, "switcher/hotkeys");
-  RimeConfigCreateList(config, "switcher/hotkeys");
-  RimeConfigIterator iterator;
-  RimeConfigBeginList(&iterator, config, "switcher/hotkeys");
-  RimeConfigNext(&iterator);
-  for(size_t i = 0; i < keys_size; i ++) {
+
+void FcitxRimeConfigSetToggleKeys(FcitxRime *rime, RimeConfig *config,
+                                  const char **keys, size_t keys_size) {
+    RimeConfigClear(config, "switcher/hotkeys");
+    RimeConfigCreateList(config, "switcher/hotkeys");
+    RimeConfigIterator iterator;
+    RimeConfigBeginList(&iterator, config, "switcher/hotkeys");
     RimeConfigNext(&iterator);
-    RimeConfigSetString(config, iterator.path, keys[i]);
-  }
+    for (size_t i = 0; i < keys_size; i++) {
+        RimeConfigNext(&iterator);
+        RimeConfigSetString(config, iterator.path, keys[i]);
+    }
 }
 
 size_t FcitxRimeConfigGetToggleKeySize(FcitxRime *rime, RimeConfig *config) {
-  return RimeConfigListSize(config, "switcher/hotkeys");
+    return RimeConfigListSize(config, "switcher/hotkeys");
 }
-  
-void FcitxRimeConfigGetToggleKeys(FcitxRime* rime, RimeConfig* config, char** keys, size_t keys_size) {
-  size_t s = RimeConfigListSize(config, "switcher/hotkeys");
-  RimeConfigIterator iterator;
-  RimeConfigBeginList(&iterator, config, "switcher/hotkeys");
-  for(size_t i = 0; i < s; i ++) {
-    RimeConfigNext(&iterator);
-    if (i >= keys_size) {
-      RimeConfigEnd(&iterator);
-      break;
-    } else {
-      char* mem = (char*) fcitx_utils_malloc0(30);
-      RimeConfigGetString(config, iterator.path, mem, 30); 
-      keys[i] = mem;
+
+void FcitxRimeConfigGetToggleKeys(FcitxRime *rime, RimeConfig *config,
+                                  char **keys, size_t keys_size) {
+    size_t s = RimeConfigListSize(config, "switcher/hotkeys");
+    RimeConfigIterator iterator;
+    RimeConfigBeginList(&iterator, config, "switcher/hotkeys");
+    for (size_t i = 0; i < s; i++) {
+        RimeConfigNext(&iterator);
+        if (i >= keys_size) {
+            RimeConfigEnd(&iterator);
+            break;
+        } else {
+            char *mem = (char *)fcitx_utils_malloc0(30);
+            RimeConfigGetString(config, iterator.path, mem, 30);
+            keys[i] = mem;
+        }
     }
-  }
 }
 
-void FcitxRimeBeginKeyBinding(RimeConfig* config) {
-  global_iterator = (RimeConfigIterator*) fcitx_utils_malloc0(sizeof(RimeConfigIterator));  
-  RimeConfigBeginList(global_iterator, config, "key_binder/bindings");
+void FcitxRimeBeginKeyBinding(RimeConfig *config) {
+    global_iterator =
+        (RimeConfigIterator *)fcitx_utils_malloc0(sizeof(RimeConfigIterator));
+    RimeConfigBeginList(global_iterator, config, "key_binder/bindings");
 }
-  
+
 size_t FcitxRimeConfigGetKeyBindingSize(RimeConfig *config) {
-  return RimeConfigListSize(config, "key_binder/bindings");
+    return RimeConfigListSize(config, "key_binder/bindings");
 }
-  
-void FcitxRimeEndKeyBinding(RimeConfig* config) {
-  fcitx_utils_free(global_iterator);
+
+void FcitxRimeEndKeyBinding(RimeConfig *config) {
+    fcitx_utils_free(global_iterator);
 }
-  
-void FcitxRimeConfigGetNextKeyBinding(RimeConfig* config, char* act_type, char* act_key, char* accept, size_t buffer_size) {
-  RimeConfigNext(global_iterator);
-  RimeConfig map;
-  memset(&map, 0, sizeof(RimeConfig));
-  RimeConfigGetItem(config, global_iterator->path, &map);
-    
-  char* accept_try = (char*) fcitx_utils_malloc0(buffer_size * sizeof(char));
-  memset(accept_try, 0 , buffer_size * sizeof(char));
-  RimeConfigGetString(&map, "accept", accept_try, buffer_size);
-    
-  char* send_try = (char*) fcitx_utils_malloc0(buffer_size * sizeof(char));
-  memset(send_try, 0 , buffer_size * sizeof(char));
-  RimeConfigGetString(&map, "send", send_try, buffer_size);
-    
-  char* toggle_try = (char*) fcitx_utils_malloc0(buffer_size * sizeof(char));
-  memset(toggle_try, 0 , buffer_size * sizeof(char));
-  RimeConfigGetString(&map, "toggle", toggle_try, buffer_size);
-    
-  if(strlen(send_try) != 0) {
-    strncpy(act_type, "send", buffer_size);
-    strncpy(act_key, send_try, buffer_size);
-  } else if (strlen(toggle_try) != 0) {
-    strncpy(act_type, "toggle", buffer_size);
-    strncpy(act_key, toggle_try, buffer_size);
-  }
-    
-  strncpy(accept, accept_try, buffer_size);
-  
-  fcitx_utils_free(accept_try);
-  fcitx_utils_free(send_try);
-  fcitx_utils_free(toggle_try);
+
+void FcitxRimeConfigGetNextKeyBinding(RimeConfig *config, char *act_type,
+                                      char *act_key, char *accept,
+                                      size_t buffer_size) {
+    RimeConfigNext(global_iterator);
+    RimeConfig map;
+    memset(&map, 0, sizeof(RimeConfig));
+    RimeConfigGetItem(config, global_iterator->path, &map);
+
+    char *accept_try = (char *)fcitx_utils_malloc0(buffer_size * sizeof(char));
+    memset(accept_try, 0, buffer_size * sizeof(char));
+    RimeConfigGetString(&map, "accept", accept_try, buffer_size);
+
+    char *send_try = (char *)fcitx_utils_malloc0(buffer_size * sizeof(char));
+    memset(send_try, 0, buffer_size * sizeof(char));
+    RimeConfigGetString(&map, "send", send_try, buffer_size);
+
+    char *toggle_try = (char *)fcitx_utils_malloc0(buffer_size * sizeof(char));
+    memset(toggle_try, 0, buffer_size * sizeof(char));
+    RimeConfigGetString(&map, "toggle", toggle_try, buffer_size);
+
+    if (strlen(send_try) != 0) {
+        strncpy(act_type, "send", buffer_size);
+        strncpy(act_key, send_try, buffer_size);
+    } else if (strlen(toggle_try) != 0) {
+        strncpy(act_type, "toggle", buffer_size);
+        strncpy(act_key, toggle_try, buffer_size);
+    }
+
+    strncpy(accept, accept_try, buffer_size);
+
+    fcitx_utils_free(accept_try);
+    fcitx_utils_free(send_try);
+    fcitx_utils_free(toggle_try);
 }
-  
+
 // type: 0: toggle, 1: send
 // key: value of the act_type, Page_Up, Page_Down, etc
 // value: shortcut
-void FcitxRimeConfigSetKeyBindingSet(RimeConfig* config, int type, const char* key, const char** shortcuts, size_t shortcut_size) {
-  RimeConfigIterator iter;
-  size_t total_sz = RimeConfigListSize(config, "key_binder/bindings");
-  RimeConfigBeginList(&iter, config, "key_binder/bindings");
-  size_t ptr = 0;
-  for(size_t i = 0; i < total_sz; i ++) {
-    RimeConfigNext(&iter);
-    RimeConfig map;
-    memset(&map, 0, sizeof(RimeConfig));
-    RimeConfigGetItem(config, iter.path, &map);
-    size_t buffer_sz = 20;
-    char* key_try = (char*) fcitx_utils_malloc0(buffer_sz * sizeof(char));
-    if(type == 0) { // "toggle"
-      RimeConfigGetString(&map, "toggle", key_try, buffer_sz);
-      if(strcmp(key_try, key) == 0) { // matches!
-	if(ptr < shortcut_size) {
-	  RimeConfigSetString(&map, "accept", shortcuts[ptr++]);
-	} else { // set the rest to ""
-	  RimeConfigSetString(&map, "accept", "");
-	}
-      }
-    } else if(type == 1) { // "send"
-      RimeConfigGetString(&map, "send", key_try, buffer_sz);
-      if(strcmp(key_try, key) == 0) { // matches!
-	if(ptr < shortcut_size) {
-	  RimeConfigSetString(&map, "accept", shortcuts[ptr++]);
-	} else { // set the rest to ""
-	  RimeConfigSetString(&map, "accept", "");
-	}
-      }
+void FcitxRimeConfigSetKeyBindingSet(RimeConfig *config, int type,
+                                     const char *key, const char **shortcuts,
+                                     size_t shortcut_size) {
+    RimeConfigIterator iter;
+    size_t total_sz = RimeConfigListSize(config, "key_binder/bindings");
+    RimeConfigBeginList(&iter, config, "key_binder/bindings");
+    size_t ptr = 0;
+    for (size_t i = 0; i < total_sz; i++) {
+        RimeConfigNext(&iter);
+        RimeConfig map;
+        memset(&map, 0, sizeof(RimeConfig));
+        RimeConfigGetItem(config, iter.path, &map);
+        size_t buffer_sz = 20;
+        char *key_try = (char *)fcitx_utils_malloc0(buffer_sz * sizeof(char));
+        if (type == 0) { // "toggle"
+            RimeConfigGetString(&map, "toggle", key_try, buffer_sz);
+            if (strcmp(key_try, key) == 0) { // matches!
+                if (ptr < shortcut_size) {
+                    RimeConfigSetString(&map, "accept", shortcuts[ptr++]);
+                } else { // set the rest to ""
+                    RimeConfigSetString(&map, "accept", "");
+                }
+            }
+        } else if (type == 1) { // "send"
+            RimeConfigGetString(&map, "send", key_try, buffer_sz);
+            if (strcmp(key_try, key) == 0) { // matches!
+                if (ptr < shortcut_size) {
+                    RimeConfigSetString(&map, "accept", shortcuts[ptr++]);
+                } else { // set the rest to ""
+                    RimeConfigSetString(&map, "accept", "");
+                }
+            }
+        }
+        fcitx_utils_free(key_try);
     }
-    fcitx_utils_free(key_try);
-  }
 }
-  
-void FcitxRimeConfigSetKeyBinding(RimeConfig* config, const char* act_type, const char* act_key, const char* value, size_t index) {
-  RimeConfigIterator iter;
-  size_t sz = RimeConfigListSize(config, "key_binder/bindings");
-  size_t j = 0;
-  RimeConfigBeginList(&iter, config, "key_binder/bindings");
-  for(size_t i = 0; i < sz; i ++) {
-    RimeConfigNext(&iter);
-    RimeConfig map;
-    memset(&map, 0, sizeof(RimeConfig));
-    RimeConfigGetItem(config, iter.path, &map);
-    size_t buffer_size = 50;
-    char* act_key_try = (char*) fcitx_utils_malloc0(buffer_size * sizeof(char));
-    RimeConfigGetString(&map, act_type, act_key_try, buffer_size);
-    if(strcmp(act_key_try, act_key) == 0) {
-      if(j == index) { // we found the index-th keyboard shortcut
-	RimeConfigSetString(&map, "accept", value);
-      } else if(j > index) {
-	RimeConfigSetString(&map, "accept", "");
-      }
-      j += 1;
+
+void FcitxRimeConfigSetKeyBinding(RimeConfig *config, const char *act_type,
+                                  const char *act_key, const char *value,
+                                  size_t index) {
+    RimeConfigIterator iter;
+    size_t sz = RimeConfigListSize(config, "key_binder/bindings");
+    size_t j = 0;
+    RimeConfigBeginList(&iter, config, "key_binder/bindings");
+    for (size_t i = 0; i < sz; i++) {
+        RimeConfigNext(&iter);
+        RimeConfig map;
+        memset(&map, 0, sizeof(RimeConfig));
+        RimeConfigGetItem(config, iter.path, &map);
+        size_t buffer_size = 50;
+        char *act_key_try =
+            (char *)fcitx_utils_malloc0(buffer_size * sizeof(char));
+        RimeConfigGetString(&map, act_type, act_key_try, buffer_size);
+        if (strcmp(act_key_try, act_key) == 0) {
+            if (j == index) { // we found the index-th keyboard shortcut
+                RimeConfigSetString(&map, "accept", value);
+            } else if (j > index) {
+                RimeConfigSetString(&map, "accept", "");
+            }
+            j += 1;
+        }
+        fcitx_utils_free(act_key_try);
     }
-    fcitx_utils_free(act_key_try);
-  }
 }
-  
-void FcitxRimeDestroy(FcitxRime* rime) {
-  RimeConfigClose(rime->default_conf);
-  rime->api->finalize();
-  fcitx_utils_free(rime);
+
+void FcitxRimeDestroy(FcitxRime *rime) {
+    RimeConfigClose(rime->default_conf);
+    rime->api->finalize();
+    fcitx_utils_free(rime);
 }
-  
+
 // Write into config file and restart rime
-void FcitxRimeConfigSync(FcitxRime* rime) {
-  RimeStartMaintenanceOnWorkspaceChange();
-  RimeConfigClose(rime->default_conf);
-  rime->api->finalize();
-  FcitxRimeConfigStart(rime);
-  FcitxRimeConfigOpenDefault(rime);
+void FcitxRimeConfigSync(FcitxRime *rime) {
+    RimeStartMaintenanceOnWorkspaceChange();
+    RimeConfigClose(rime->default_conf);
+    rime->api->finalize();
+    FcitxRimeConfigStart(rime);
+    FcitxRimeConfigOpenDefault(rime);
 }
-  
-void FcitxRimeGetSchemaAttr(FcitxRime* rime, const char* schema_id, char* name, size_t buffer_size, const char* attr) {
-  RimeConfig rime_schema_config;
-  memset(&rime_schema_config, 0, sizeof(RimeConfig));
-  RimeSchemaOpen(schema_id, &rime_schema_config);
-  RimeConfigGetString(&rime_schema_config, attr, name, buffer_size);
-  RimeConfigClose(&rime_schema_config);
+
+void FcitxRimeGetSchemaAttr(FcitxRime *rime, const char *schema_id, char *name,
+                            size_t buffer_size, const char *attr) {
+    RimeConfig rime_schema_config;
+    memset(&rime_schema_config, 0, sizeof(RimeConfig));
+    RimeSchemaOpen(schema_id, &rime_schema_config);
+    RimeConfigGetString(&rime_schema_config, attr, name, buffer_size);
+    RimeConfigClose(&rime_schema_config);
 }
 
 // reset active schema list to nothing
-void FcitxRimeClearAndSetSchemaList(FcitxRime* rime, RimeConfig* config,
-				    char ** schema_names, size_t count) {
-  RimeConfigClear(config, "schema_list");
-  RimeConfigCreateList(config, "schema_list");
-  RimeConfigIterator iterator;
-  RimeConfigBeginList(&iterator, config, "schema_list");
-  RimeConfigNext(&iterator);
-  for(size_t i = 0; i < count; i ++) {
+void FcitxRimeClearAndSetSchemaList(FcitxRime *rime, RimeConfig *config,
+                                    char **schema_names, size_t count) {
+    RimeConfigClear(config, "schema_list");
+    RimeConfigCreateList(config, "schema_list");
+    RimeConfigIterator iterator;
+    RimeConfigBeginList(&iterator, config, "schema_list");
     RimeConfigNext(&iterator);
-    RimeConfigCreateMap(config, iterator.path);
-    RimeConfig map;
-    memset(&map, 0, sizeof(RimeConfig));
-    RimeConfigGetItem(config, iterator.path, &map);
-    RimeConfigSetString(&map, "schema", schema_names[i]);
-  }
-  return;
+    for (size_t i = 0; i < count; i++) {
+        RimeConfigNext(&iterator);
+        RimeConfigCreateMap(config, iterator.path);
+        RimeConfig map;
+        memset(&map, 0, sizeof(RimeConfig));
+        RimeConfigGetItem(config, iterator.path, &map);
+        RimeConfigSetString(&map, "schema", schema_names[i]);
+    }
+    return;
 }
-  
-int FcitxRimeCheckSchemaEnabled(FcitxRime* rime, RimeConfig* config, const char* schema_id) {
-  size_t s = RimeConfigListSize(config, "schema_list");
-  RimeConfigIterator iterator;
-  RimeConfigBeginList(&iterator, config, "schema_list");
-  int result = 0;
-  for(size_t i = 0; i < s; i ++) {
-    RimeConfigNext(&iterator);
-    RimeConfig map;
-    memset(&map, 0, sizeof(RimeConfig));
-    RimeConfigGetItem(config, iterator.path, &map);
-    size_t buffer_size = 50;
-    char* s = (char*) fcitx_utils_malloc0(buffer_size * sizeof(char));
-    RimeConfigGetString(&map, "schema", s, buffer_size);
-    if (strcmp(s, schema_id) == 0) { /* This schema is enabled in default*/        
-      result = (i+1);
+
+int FcitxRimeCheckSchemaEnabled(FcitxRime *rime, RimeConfig *config,
+                                const char *schema_id) {
+    size_t s = RimeConfigListSize(config, "schema_list");
+    RimeConfigIterator iterator;
+    RimeConfigBeginList(&iterator, config, "schema_list");
+    int result = 0;
+    for (size_t i = 0; i < s; i++) {
+        RimeConfigNext(&iterator);
+        RimeConfig map;
+        memset(&map, 0, sizeof(RimeConfig));
+        RimeConfigGetItem(config, iterator.path, &map);
+        size_t buffer_size = 50;
+        char *s = (char *)fcitx_utils_malloc0(buffer_size * sizeof(char));
+        RimeConfigGetString(&map, "schema", s, buffer_size);
+        if (strcmp(s, schema_id) == 0) { /* This schema is enabled in default*/
+            result = (i + 1);
+        }
     }
-  }
-  return result;
+    return result;
 }
-  
diff --git a/gui/src/FcitxRimeConfig.h b/gui/src/FcitxRimeConfig.h
index c0be639..268e40d 100644
--- a/gui/src/FcitxRimeConfig.h
+++ b/gui/src/FcitxRimeConfig.h
@@ -10,7 +10,7 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
@@ -20,38 +20,47 @@
 
 #include <rime_api.h>
 
-static constexpr const char* fcitx_rime_dir_prefix = "rime";
-static constexpr const char* fcitx_rime_schema_suffix = ".schema.yaml";
-  
+static constexpr const char *fcitx_rime_dir_prefix = "rime";
+static constexpr const char *fcitx_rime_schema_suffix = ".schema.yaml";
+
 typedef struct _FcitxRime {
-  RimeApi* api;
-  RimeConfig* default_conf;
-  RimeConfig* custom_conf;
-  Bool firstRun;
+    RimeApi *api;
+    RimeConfig *default_conf;
+    RimeConfig *custom_conf;
+    Bool firstRun;
 } FcitxRime;
-  
+
 // open and start, sync and close
-FcitxRime* FcitxRimeConfigCreate();
-void FcitxRimeConfigStart(FcitxRime* rime);
-RimeConfig* FcitxRimeConfigOpenDefault(FcitxRime* rime);
-void FcitxRimeConfigSync(FcitxRime* rime);
-void FcitxRimeDestroy(FcitxRime* rime);
+FcitxRime *FcitxRimeConfigCreate();
+void FcitxRimeConfigStart(FcitxRime *rime);
+RimeConfig *FcitxRimeConfigOpenDefault(FcitxRime *rime);
+void FcitxRimeConfigSync(FcitxRime *rime);
+void FcitxRimeDestroy(FcitxRime *rime);
 // toggle
 size_t FcitxRimeConfigGetToggleKeySize(FcitxRime *rime, RimeConfig *config);
-void FcitxRimeConfigGetToggleKeys(FcitxRime* rime, RimeConfig* config, char** keys, size_t keys_size);
-void FcitxRimeConfigSetToggleKeys(FcitxRime* rime, RimeConfig* config, const char** keys,
-				  size_t keys_size);
+void FcitxRimeConfigGetToggleKeys(FcitxRime *rime, RimeConfig *config,
+                                  char **keys, size_t keys_size);
+void FcitxRimeConfigSetToggleKeys(FcitxRime *rime, RimeConfig *config,
+                                  const char **keys, size_t keys_size);
 // other bindings
-void FcitxRimeBeginKeyBinding(RimeConfig* config);
+void FcitxRimeBeginKeyBinding(RimeConfig *config);
 size_t FcitxRimeConfigGetKeyBindingSize(RimeConfig *config);
-void FcitxRimeConfigGetNextKeyBinding(RimeConfig* config, char* act_type, char* act_key, char* accept, size_t buffer_size);
-void FcitxRimeEndKeyBinding(RimeConfig* config);
-void FcitxRimeConfigSetKeyBinding(RimeConfig* config, const char* act_type, const char* act_key, const char* value, size_t index);
-void FcitxRimeConfigSetKeyBindingSet(RimeConfig* config, int type, const char* key, const char** shortcuts, size_t shortcut_size);
+void FcitxRimeConfigGetNextKeyBinding(RimeConfig *config, char *act_type,
+                                      char *act_key, char *accept,
+                                      size_t buffer_size);
+void FcitxRimeEndKeyBinding(RimeConfig *config);
+void FcitxRimeConfigSetKeyBinding(RimeConfig *config, const char *act_type,
+                                  const char *act_key, const char *value,
+                                  size_t index);
+void FcitxRimeConfigSetKeyBindingSet(RimeConfig *config, int type,
+                                     const char *key, const char **shortcuts,
+                                     size_t shortcut_size);
 // schemas
-void FcitxRimeGetSchemaAttr(FcitxRime* rime, const char* schema_id, char* name, size_t buffer_size, const char* attr);
-int FcitxRimeCheckSchemaEnabled(FcitxRime* rime, RimeConfig* config, const char* schema_id);
-void FcitxRimeClearAndSetSchemaList(FcitxRime* rime, RimeConfig* config,
-				    char ** schema_names, size_t count);
+void FcitxRimeGetSchemaAttr(FcitxRime *rime, const char *schema_id, char *name,
+                            size_t buffer_size, const char *attr);
+int FcitxRimeCheckSchemaEnabled(FcitxRime *rime, RimeConfig *config,
+                                const char *schema_id);
+void FcitxRimeClearAndSetSchemaList(FcitxRime *rime, RimeConfig *config,
+                                    char **schema_names, size_t count);
 
 #endif // FCITX_RIME_CONFIG_H
diff --git a/gui/src/Main.cpp b/gui/src/Main.cpp
index 5b8e2ca..fc7d475 100644
--- a/gui/src/Main.cpp
+++ b/gui/src/Main.cpp
@@ -10,38 +10,31 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
 //
-#include <qplugin.h>
 #include <fcitx-utils/utils.h>
+#include <qplugin.h>
 
 #include "ConfigMain.h"
 #include "Main.h"
 
 // FcitxQtConfigUIPlugin : QObject, FcitxQtConfigUIFactoryInterface
-FcitxRimeConfigTool::FcitxRimeConfigTool(QObject* parent)
-  : FcitxQtConfigUIPlugin(parent) {
-  if (parent == NULL) {
-  }
+FcitxRimeConfigTool::FcitxRimeConfigTool(QObject *parent)
+    : FcitxQtConfigUIPlugin(parent) {
+    if (parent == NULL) {
+    }
 }
 
-FcitxQtConfigUIWidget* FcitxRimeConfigTool::create(const QString& key)
-{
-  Q_UNUSED(key);
-  return new fcitx_rime::ConfigMain;
+FcitxQtConfigUIWidget *FcitxRimeConfigTool::create(const QString &key) {
+    Q_UNUSED(key);
+    return new fcitx_rime::ConfigMain;
 }
 
-QString FcitxRimeConfigTool::name() {
-  return "rime-config-gui-tool";
-}
+QString FcitxRimeConfigTool::name() { return "rime-config-gui-tool"; }
 
-QStringList FcitxRimeConfigTool::files() {
-  return QStringList("rime/config");
-}
+QStringList FcitxRimeConfigTool::files() { return QStringList("rime/config"); }
 
-QString FcitxRimeConfigTool::domain() {
-  return "fcitx_rime";
-}
+QString FcitxRimeConfigTool::domain() { return "fcitx_rime"; }
diff --git a/gui/src/Main.h b/gui/src/Main.h
index be28e83..7cf0722 100644
--- a/gui/src/Main.h
+++ b/gui/src/Main.h
@@ -10,7 +10,7 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
@@ -23,12 +23,13 @@
 class FcitxRimeConfigTool : public FcitxQtConfigUIPlugin {
     Q_OBJECT
 public:
-    Q_PLUGIN_METADATA(IID "FcitxQtConfigUIFactoryInterface_iid" FILE "fcitx-rime-config.json")
-    explicit FcitxRimeConfigTool(QObject* parent = 0);
+    Q_PLUGIN_METADATA(IID "FcitxQtConfigUIFactoryInterface_iid" FILE
+                          "fcitx-rime-config.json")
+    explicit FcitxRimeConfigTool(QObject *parent = 0);
     QString name() override;
     QStringList files() override;
     QString domain() override;
-    FcitxQtConfigUIWidget* create(const QString& key) override;
+    FcitxQtConfigUIWidget *create(const QString &key) override;
 };
 
 #endif // FCITX_RIME_MAIN_H
diff --git a/gui/src/Model.cpp b/gui/src/Model.cpp
index b9e6562..bbd62dd 100644
--- a/gui/src/Model.cpp
+++ b/gui/src/Model.cpp
@@ -10,70 +10,72 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
 //
-#include <fcitxqtkeysequencewidget.h>
-#include "keynametable.h"
 #include "Model.h"
 #include "Common.h"
-#include <iostream>
+#include "keynametable.h"
 #include <algorithm>
+#include <fcitxqtkeysequencewidget.h>
+#include <iostream>
 
 namespace fcitx_rime {
-  void FcitxRimeConfigDataModel::sortSchemas() {
-    std::sort(schemas_.begin(), schemas_.end(), [] (const FcitxRimeSchema& a, const FcitxRimeSchema& b) -> bool {
-	// if both inactive, sort by id
-	if(a.index == 0 && b.index == 0) {
-	  return a.id < b.id;
-	}
-	if(a.index == 0) {
-	  return false;
-	}
-	if(b.index == 0) {
-	  return true;
-	}
-	return (a.index < b.index);
-      });
-  }
-  
-  void FcitxRimeConfigDataModel::sortKeys() {
+void FcitxRimeConfigDataModel::sortSchemas() {
+    std::sort(schemas_.begin(), schemas_.end(),
+              [](const FcitxRimeSchema &a, const FcitxRimeSchema &b) -> bool {
+                  // if both inactive, sort by id
+                  if (a.index == 0 && b.index == 0) {
+                      return a.id < b.id;
+                  }
+                  if (a.index == 0) {
+                      return false;
+                  }
+                  if (b.index == 0) {
+                      return true;
+                  }
+                  return (a.index < b.index);
+              });
+}
+
+void FcitxRimeConfigDataModel::sortKeys() {
     sortSingleKeySet(toggle_keys);
     sortSingleKeySet(ascii_key);
     sortSingleKeySet(trasim_key);
     sortSingleKeySet(halffull_key);
     sortSingleKeySet(pgup_key);
     sortSingleKeySet(pgdown_key);
-  }
-
-  void FcitxRimeConfigDataModel::sortSingleKeySet(QVector<FcitxKeySeq>& keys) {
-    std::sort(keys.begin(), keys.end(), [] (const FcitxKeySeq& a, const FcitxKeySeq& b) -> bool {
-	auto qa = QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(a.sym_, a.states_));
-	auto qb = QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(b.sym_, b.states_));
-	return qa.toString().length() < qb.toString().length();
-      });
-  }
-  
-  // default constructor
-  FcitxKeySeq::FcitxKeySeq() {
-  }
-  
-  
-  // convert keyseq to state and sym
-  FcitxKeySeq::FcitxKeySeq(const char* keyseq) {
+}
+
+void FcitxRimeConfigDataModel::sortSingleKeySet(QVector<FcitxKeySeq> &keys) {
+    std::sort(keys.begin(), keys.end(),
+              [](const FcitxKeySeq &a, const FcitxKeySeq &b) -> bool {
+                  auto qa = QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(
+                      a.sym_, a.states_));
+                  auto qb = QKeySequence(FcitxQtKeySequenceWidget::keyFcitxToQt(
+                      b.sym_, b.states_));
+                  return qa.toString().length() < qb.toString().length();
+              });
+}
+
+// default constructor
+FcitxKeySeq::FcitxKeySeq() {}
+
+// convert keyseq to state and sym
+FcitxKeySeq::FcitxKeySeq(const char *keyseq) {
     KeyStates states;
     const char *p = keyseq;
     const char *lastModifier = keyseq;
     const char *found = nullptr;
-    // use macro to check modifiers
-    #define _CHECK_MODIFIER(NAME, VALUE)                                                                                   \
-    if ((found = strstr(p, NAME))) {                                                                                   \
-        states |= fcitx::KeyState::VALUE;                                                                                     \
-        if (found + strlen(NAME) > lastModifier) {                                                                     \
-            lastModifier = found + strlen(NAME);                                                                       \
-        }                                                                                                              \
+// use macro to check modifiers
+#define _CHECK_MODIFIER(NAME, VALUE)                                           \
+    if ((found = strstr(p, NAME))) {                                           \
+        states |= fcitx::KeyState::VALUE;                                      \
+        if (found + strlen(NAME) > lastModifier) {                             \
+            lastModifier = found + strlen(NAME);                               \
+        }                                                                      \
     }
 
     _CHECK_MODIFIER("CTRL_", Ctrl)
@@ -84,75 +86,84 @@ namespace fcitx_rime {
     _CHECK_MODIFIER("Shift+", Shift)
     _CHECK_MODIFIER("SUPER_", Super)
     _CHECK_MODIFIER("Super+", Super)
-    
+
 #undef _CHECK_MODIFIER
     sym_ = keySymFromString(lastModifier);
     states_ = states;
-  }
-  
-  KeySym FcitxKeySeq::keySymFromString(const char* keyString) {
+}
+
+KeySym FcitxKeySeq::keySymFromString(const char *keyString) {
     auto value = std::lower_bound(
-        keyValueByNameOffset, keyValueByNameOffset + FCITX_RIME_ARRAY_SIZE(keyValueByNameOffset), keyString,
-        [](const uint32_t &idx, const std::string &str) { return keyNameList[&idx - keyValueByNameOffset] < str; });
-    if (value != keyValueByNameOffset + FCITX_RIME_ARRAY_SIZE(keyValueByNameOffset) &&
-      strcmp(keyString, keyNameList[value - keyValueByNameOffset]) == 0) {
-      return static_cast<KeySym>(*value);
+        keyValueByNameOffset,
+        keyValueByNameOffset + FCITX_RIME_ARRAY_SIZE(keyValueByNameOffset),
+        keyString, [](const uint32_t &idx, const std::string &str) {
+            return keyNameList[&idx - keyValueByNameOffset] < str;
+        });
+    if (value != keyValueByNameOffset +
+                     FCITX_RIME_ARRAY_SIZE(keyValueByNameOffset) &&
+        strcmp(keyString, keyNameList[value - keyValueByNameOffset]) == 0) {
+        return static_cast<KeySym>(*value);
     }
 
-     return FcitxKey_None;
-  }
-  
-  
-  std::string FcitxKeySeq::keySymToString(KeySym sym) const {
-    const KeyNameOffsetByValue *result =
-    std::lower_bound(keyNameOffsetByValue, keyNameOffsetByValue + FCITX_RIME_ARRAY_SIZE(keyNameOffsetByValue), sym,
-                      [](const KeyNameOffsetByValue &item, KeySym key) { return item.sym < key; });
-    if (result != keyNameOffsetByValue + FCITX_RIME_ARRAY_SIZE(keyNameOffsetByValue) && result->sym == sym) {
-      return keyNameList[result->offset];
+    return FcitxKey_None;
+}
+
+std::string FcitxKeySeq::keySymToString(KeySym sym) const {
+    const KeyNameOffsetByValue *result = std::lower_bound(
+        keyNameOffsetByValue,
+        keyNameOffsetByValue + FCITX_RIME_ARRAY_SIZE(keyNameOffsetByValue), sym,
+        [](const KeyNameOffsetByValue &item, KeySym key) {
+            return item.sym < key;
+        });
+    if (result != keyNameOffsetByValue +
+                      FCITX_RIME_ARRAY_SIZE(keyNameOffsetByValue) &&
+        result->sym == sym) {
+        return keyNameList[result->offset];
     }
     return std::string();
-  }
-  
-  // convert QKeySequence to state and sym
-  FcitxKeySeq::FcitxKeySeq(const QKeySequence qkey) {
+}
+
+// convert QKeySequence to state and sym
+FcitxKeySeq::FcitxKeySeq(const QKeySequence qkey) {
     int sym = 0;
     uint states = 0;
     int qkeycode = static_cast<int>(qkey[0]);
-    FcitxQtKeySequenceWidget::keyQtToFcitx(qkeycode, FcitxQtModifierSide::MS_Unknown, sym, states);
+    FcitxQtKeySequenceWidget::keyQtToFcitx(
+        qkeycode, FcitxQtModifierSide::MS_Unknown, sym, states);
     sym_ = static_cast<FcitxKeySym>(sym);
     states_ = static_cast<fcitx::KeyState>(states);
-  }
-  
-  // convert to Rime X11 style string
-  std::string FcitxKeySeq::toString() const {
+}
+
+// convert to Rime X11 style string
+std::string FcitxKeySeq::toString() const {
     auto sym = sym_;
     if (sym == FcitxKey_None) {
-      return std::string();
+        return std::string();
     }
     if (sym == FcitxKey_ISO_Left_Tab) {
-      sym = FcitxKey_Tab;          
+        sym = FcitxKey_Tab;
     }
-    
+
     auto key = keySymToString(sym);
 
     if (key.empty()) {
-      return std::string();
+        return std::string();
     }
 
     std::string str;
-    
-    #define _APPEND_MODIFIER_STRING(STR, VALUE)                                                                         \
-    if (states_ & fcitx::KeyState::VALUE) {                                                                                   \
-        str += STR;                                                                                                   \
+
+#define _APPEND_MODIFIER_STRING(STR, VALUE)                                    \
+    if (states_ & fcitx::KeyState::VALUE) {                                    \
+        str += STR;                                                            \
     }
-    
+
     _APPEND_MODIFIER_STRING("Control+", Ctrl)
     _APPEND_MODIFIER_STRING("Alt+", Alt)
     _APPEND_MODIFIER_STRING("Shift+", Shift)
     _APPEND_MODIFIER_STRING("Super+", Super)
 
-    #undef _APPEND_MODIFIER_STRING
+#undef _APPEND_MODIFIER_STRING
     str += key;
     return str;
-  }
 }
+} // namespace fcitx_rime
diff --git a/gui/src/Model.h b/gui/src/Model.h
index 9943044..355760b 100644
--- a/gui/src/Model.h
+++ b/gui/src/Model.h
@@ -10,7 +10,7 @@
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 // General Public License for more details.
-
+//
 // You should have received a copy of the GNU General Public License
 // along with this program; see the file COPYING. If not,
 // see <http://www.gnu.org/licenses/>.
@@ -18,42 +18,42 @@
 #ifndef FCITX_RIME_MODEL_H
 #define FCITX_RIME_MODEL_H
 
-#include <rime_api.h>
-
 #include "keysym.h"
 #include "keysymgen.h"
-#include <QKeySequence>
 #include <QFlags>
+#include <QKeySequence>
+#include <QVector>
+#include <rime_api.h>
 
 static constexpr int max_shortcuts = 3;
 static constexpr int default_page_size = 5;
 
 namespace fcitx_rime {
-  typedef QFlags<fcitx::KeyState> KeyStates;
-  typedef FcitxKeySym KeySym;
-  class FcitxKeySeq {
-  public:
+typedef QFlags<fcitx::KeyState> KeyStates;
+typedef FcitxKeySym KeySym;
+class FcitxKeySeq {
+public:
     KeyStates states_;
     KeySym sym_;
     FcitxKeySeq();
-    FcitxKeySeq(const char* keyseq);
+    FcitxKeySeq(const char *keyseq);
     FcitxKeySeq(const QKeySequence qkey);
     std::string toString() const;
     std::string keySymToString(KeySym sym) const;
-    KeySym keySymFromString(const char* keyString);
-  };
-  
-  class FcitxRimeSchema {
-  public:
+    KeySym keySymFromString(const char *keyString);
+};
+
+class FcitxRimeSchema {
+public:
     QString path;
     QString id;
     QString name;
     int index; // index starts from 1, 0 means not enabled
     bool active;
-  };  
-  
-  class FcitxRimeConfigDataModel {
-    public:
+};
+
+class FcitxRimeConfigDataModel {
+public:
     QVector<FcitxKeySeq> toggle_keys;
     QVector<FcitxKeySeq> ascii_key;
     QVector<FcitxKeySeq> trasim_key;
@@ -64,9 +64,10 @@ namespace fcitx_rime {
     QVector<FcitxRimeSchema> schemas_;
     void sortSchemas();
     void sortKeys();
-    private:
-    void sortSingleKeySet(QVector<FcitxKeySeq>& keys);
-  };
-}
+
+private:
+    void sortSingleKeySet(QVector<FcitxKeySeq> &keys);
+};
+} // namespace fcitx_rime
 
 #endif // FCITX_RIME_MODEL_H
diff --git a/gui/src/keysym.h b/gui/src/keysym.h
index 63eca9b..794a679 100644
--- a/gui/src/keysym.h
+++ b/gui/src/keysym.h
@@ -50,6 +50,6 @@ enum class KeyState : uint32_t {
     UsedMask = 0x5c001fff,
     SimpleMask = Ctrl_Alt_Shift | Super | Super2 | Hyper | Meta,
 };
-}
+} // namespace fcitx
 
 #endif
